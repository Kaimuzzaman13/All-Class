{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "64f73cd5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Population initialization: \n",
      " [[4, 1, 2, 3, 0], [2, 1, 4, 0, 3], [2, 3, 0, 4, 1], [0, 1, 3, 2, 4], [2, 0, 4, 1, 3], [3, 1, 4, 2, 0], [1, 4, 0, 2, 3], [2, 0, 1, 3, 4], [2, 0, 4, 3, 1], [2, 1, 0, 3, 4]]\n",
      "Population's paths length: \n",
      " [16, 17, 17, 12, 15, 15, 14, 17, 16, 19]\n",
      "Best route of generation 1 :  [3, 1, 2, 0, 4] \n",
      "Route length:  12\n",
      "Population of generation 1 : \n",
      " [[2, 1, 3, 0, 4], [2, 0, 1, 4, 3], [3, 1, 2, 0, 4], [0, 1, 3, 2, 4], [2, 0, 1, 4, 3], [0, 1, 3, 2, 4], [2, 0, 1, 4, 3], [0, 1, 3, 2, 4], [2, 0, 1, 4, 3], [0, 1, 3, 2, 4]]\n",
      "Routes lengths: [15, 19, 12, 12, 19, 12, 19, 12, 19, 12] \n",
      "\n",
      "Best route of generation 2 :  [2, 4, 3, 1, 0] \n",
      "Route length:  16\n",
      "Population of generation 2 : \n",
      " [[4, 3, 0, 1, 2], [2, 4, 3, 1, 0], [2, 4, 3, 1, 0], [2, 4, 3, 1, 0], [2, 4, 3, 1, 0], [2, 4, 3, 1, 0], [4, 3, 0, 1, 2], [4, 3, 0, 1, 2], [4, 3, 0, 1, 2], [2, 4, 3, 1, 0]]\n",
      "Routes lengths: [19, 16, 16, 16, 16, 16, 19, 19, 19, 16] \n",
      "\n",
      "Best route of generation 3 :  [0, 2, 3, 1, 4] \n",
      "Route length:  14\n",
      "Population of generation 3 : \n",
      " [[0, 2, 3, 1, 4], [0, 2, 3, 1, 4], [0, 2, 3, 1, 4], [2, 3, 4, 1, 0], [0, 2, 3, 1, 4], [0, 2, 3, 1, 4], [0, 2, 3, 1, 4], [2, 3, 4, 1, 0], [0, 2, 3, 1, 4], [2, 3, 4, 1, 0]]\n",
      "Routes lengths: [14, 14, 14, 17, 14, 14, 14, 17, 14, 17] \n",
      "\n",
      "Best route of generation 4 :  [3, 2, 0, 1, 4] \n",
      "Route length:  15\n",
      "Population of generation 4 : \n",
      " [[2, 4, 3, 1, 0], [3, 2, 0, 1, 4], [2, 4, 3, 1, 0], [2, 4, 3, 1, 0], [3, 2, 0, 1, 4], [2, 4, 3, 1, 0], [2, 4, 3, 1, 0], [2, 4, 3, 1, 0], [3, 2, 0, 1, 4], [3, 2, 0, 1, 4]]\n",
      "Routes lengths: [16, 15, 16, 16, 15, 16, 16, 16, 15, 15] \n",
      "\n",
      "Best path is: [2, 4, 3, 1, 0] with length 12\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "\n",
    "population = []  # list that holds paths\n",
    "population_size = 10  # max 120 combinations\n",
    "mutate_prob = 0.1\n",
    "n_generations = 4\n",
    "routes_length = [0]*population_size\n",
    "fitness = [0]*population_size\n",
    "best_path = 1000\n",
    "\n",
    "cities = [0, 1, 2, 3, 4]\n",
    "\n",
    "# distance matrix for our cities\n",
    "distances = [[0, 4, 4, 7, 3],\n",
    "             [4, 0, 2, 3, 5],\n",
    "             [4, 2, 0, 2, 3],\n",
    "             [7, 3, 2, 0, 6],\n",
    "             [3, 5, 3, 6, 0]]\n",
    "\n",
    "\n",
    "# calculates distance between 2 cities\n",
    "def calc_distance(city1, city2):\n",
    "    return distances[city1][city2]  # ord('A')=65\n",
    "\n",
    "\n",
    "# creates a random route\n",
    "def create_route():\n",
    "    shuffled = random.sample(cities, len(cities))\n",
    "    return shuffled\n",
    "\n",
    "\n",
    "# calculates length of an route\n",
    "def calc_route_length():\n",
    "    for i in range(population_size):\n",
    "        route_l = 0\n",
    "        for j in range(1, len(cities)):\n",
    "            route_l = route_l + calc_distance(population[i][j - 1], population[i][j])\n",
    "        # route_l = route_l + calc_distance(population[i][len(cities)-1], population[i][1]) calculate distance from last to first\n",
    "        routes_length[i] = route_l\n",
    "        fitness[i] = 1 / routes_length[i]\n",
    "\n",
    "\n",
    "# creates starting population\n",
    "def create_population():\n",
    "    for i in range(population_size):\n",
    "        population.append(create_route())\n",
    "\n",
    "\n",
    "# swap with a probability 2 cities in a route\n",
    "def swap_mutation(ind):\n",
    "    picks = random.sample(range(len(cities)), 2)\n",
    "    temp = population[ind][picks[0]]\n",
    "    population[ind][picks[0]] = population[ind][picks[1]]\n",
    "    population[ind][picks[1]] = temp\n",
    "    # print(\"Mutated path: \", population[ind])\n",
    "\n",
    "\n",
    "# PMX crossover\n",
    "def partially_matched_crossover(ind1, ind2):\n",
    "    size = len(cities)\n",
    "    p1, p2 = [0] * size, [0] * size\n",
    "\n",
    "    # Initialize the position of each indices in the individuals\n",
    "    for k in range(size):\n",
    "        p1[ind1[k]] = k\n",
    "        p2[ind2[k]] = k\n",
    "    # Choose crossover points\n",
    "    cxpoint1 = random.randint(0, size)\n",
    "    cxpoint2 = random.randint(0, size - 1)\n",
    "    if cxpoint2 >= cxpoint1:\n",
    "        cxpoint2 += 1\n",
    "    else:  # Swap the two cx points\n",
    "        cxpoint1, cxpoint2 = cxpoint2, cxpoint1\n",
    "\n",
    "# Apply crossover between cx points\n",
    "    for k in range(cxpoint1, cxpoint2):\n",
    "    # Keep track of the selected values\n",
    "        temp1 = ind1[k]\n",
    "        temp2 = ind2[k]\n",
    "    # Swap the matched value\n",
    "        ind1[k], ind1[p1[temp2]] = temp2, temp1\n",
    "        ind2[k], ind2[p2[temp1]] = temp1, temp2\n",
    "    # Position bookkeeping\n",
    "        p1[temp1], p1[temp2] = p1[temp2], p1[temp1]\n",
    "        p2[temp1], p2[temp2] = p2[temp2], p2[temp1]\n",
    "\n",
    "    return ind1, ind2\n",
    "\n",
    "\n",
    "# function that picks a parent Fitness Proportionate Selection\n",
    "def roulette_wheel_selection():\n",
    "    s = 0\n",
    "    partial_s = 0\n",
    "    ind = 0\n",
    "    for m in range(population_size):\n",
    "        s = s + fitness[m]\n",
    "    rand = random.uniform(0, s)\n",
    "    for m in range(population_size):\n",
    "        if partial_s < rand:\n",
    "            partial_s = partial_s + fitness[m]\n",
    "            ind = ind + 1\n",
    "    if ind == population_size:  # prevent out of bounds list\n",
    "        ind = population_size - 1\n",
    "    return ind\n",
    "\n",
    "\n",
    "# find fittest path called every generation\n",
    "def find_fittest():\n",
    "    key = 1000\n",
    "    fittest = 0\n",
    "    for i in range(population_size):\n",
    "        if routes_length[i] < key:\n",
    "            key = routes_length[i]\n",
    "            fittest = i\n",
    "    return fittest\n",
    "\n",
    "\n",
    "# sorts parallely the lists\n",
    "#def sort_alongside(routes_length, population):\n",
    "#    routes_length, population = (list(i) for i in zip(*sorted(zip(routes_length, population))))\n",
    "\n",
    "\n",
    "# initialize algorithm\n",
    "create_population()\n",
    "print(\"Population initialization:\", \"\\n\", population)\n",
    "calc_route_length()\n",
    "print(\"Population's paths length:\", \"\\n\", routes_length)\n",
    "\n",
    "for j in range(n_generations):\n",
    "    for i in range(0, population_size, 2):\n",
    "        # pick parents for crossover\n",
    "        parent1 = roulette_wheel_selection()\n",
    "        parent2 = roulette_wheel_selection()\n",
    "        # always pick different parents (not necessary)\n",
    "        while True:\n",
    "            if parent1 == parent2:\n",
    "                parent2 = roulette_wheel_selection()\n",
    "            else:\n",
    "                break\n",
    "        # update population\n",
    "        population[i], population[i + 1] = partially_matched_crossover(population[parent1], population[parent2])\n",
    "        # calculate lengths for updated generation\n",
    "        calc_route_length()\n",
    "\n",
    "    # pick the paths for mutation based on a probability\n",
    "    for i in range(population_size):\n",
    "        rand = random.uniform(0, 1)\n",
    "        if rand < mutate_prob:\n",
    "            swap_mutation(i)\n",
    "\n",
    "    # calculate lengths after mutation\n",
    "    calc_route_length()\n",
    "\n",
    "    # find best path overall\n",
    "    if routes_length[find_fittest()] < best_path:\n",
    "        index = find_fittest()\n",
    "        best_path = routes_length[index]\n",
    "\n",
    "    print(\"Best route of generation\", j+1, \": \", population[find_fittest()], \"\\n\" \"Route length: \",\n",
    "          routes_length[find_fittest()])\n",
    "    print(\"Population of generation\", j+1, \": \\n\", population)\n",
    "    print(\"Routes lengths:\", routes_length, \"\\n\")\n",
    "print(\"Best path is:\", population[index], \"with length\", best_path)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a9a22fd9",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
